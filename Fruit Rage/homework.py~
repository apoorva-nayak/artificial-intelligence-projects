#!/usr/bin/python
import sys
import time
import copy
import random
import math

start = time.time()

def file_write(board_state_after_gravity, max_position):
	row = max_position[0][0]
	col = max_position[0][1]
	str_output = chr(65 + col)
	str_output = str_output + str(row + 1)
	file_output.write(str_output)
	file_output.write("\n")
	for i in range(0, len(board_state_after_gravity)):
		str_output = ""
		for j in range(0, len(board_state_after_gravity[i])):
			str_output = str_output + str(board_state_after_gravity[i][j])
		if(i != (len(board_state_after_gravity) - 1)):
			file_output.write(str_output)
			file_output.write("\n")
		else:
			file_output.write(str_output)
			
def find_best_move(board_state, max_depth, time_remaining_given):
	main_dict, main_list = find_consecutive_fruit_counts(board_state)
	alpha = float("-inf")
	beta = float("inf")
	best_score = float("-inf")
	best_key = main_list[0]
	
	#Calibrate depth based on time remaining
	if len(main_list) >= 500:
		if time_remaining_given < 200:
			max_depth = 0
	
	elif len(main_list) >= 350:		
		if time_remaining_given < 150:
			max_depth = 0
	
	elif len(main_list) >= 200:		
		if time_remaining_given < 125:
			max_depth = 0
	
	elif len(main_list) >= 100:		
		if time_remaining_given < 100:
			max_depth = 0

	for ml in main_list:
		if time_remaining_given*0.9 < time.time()-start:
			return main_dict[best_key]
		key = ml
		cloned_board_state = copy.deepcopy(board_state)
		val = main_dict[key]
		cloned_board_state = gravity_effect(cloned_board_state, val)
		score = minimax(cloned_board_state, 1, False, len(val) * len(val), alpha, beta, max_depth)
		if score > alpha:
			best_key = key
			alpha = score
	return main_dict[best_key]
		
def evaluation_function(board_state, isMax, points):
	main_dict, main_list = find_consecutive_fruit_counts(board_state)
	cloned_board_state = copy.deepcopy(board_state)
	#print "Eval", main_dict[main_list[0]]
	count_fruits = len(main_dict[main_list[0]])
	#print "CN", count_fruits
	if isMax:
		return (points + count_fruits*count_fruits)
	else:
		return (points - count_fruits*count_fruits)

def minimax(board_state, depth, isMax, points, alpha, beta, max_depth):

	# terminal condition
	if check_board_empty(board_state):
		#print "Empty", points
		return points
	
	if depth > max_depth:
			#print "depth", depth
			return evaluation_function(board_state, isMax, points)
	
	if isMax:
		if depth > max_depth:
			print "depth", depth
			return evaluation_function(board_state, isMax, points)
			
        	best_score = float('-inf')
        	main_dict, main_list = find_consecutive_fruit_counts(board_state)
        	#print "depth", depth
        	#print "Max main dict", main_dict
		for ml in main_list:
			key = ml
			cloned_board_state = copy.deepcopy(board_state)
			val = main_dict[key]
            		#print "Max val", val
			cloned_board_state = gravity_effect(cloned_board_state, val)
			#print "Max Board State after gravity", cloned_board_state
            		best_score = max(best_score, minimax(cloned_board_state, depth+1, False, points+(len(val) * len(val)), alpha, beta, max_depth))
            		#print "Max Best score", best_score
            			
            		
            		#print "Alpha", alpha
            		if best_score >= beta:
            			#print "Best_score", best_score
            			#print "********Pruned********"
            			#global prune_count
            			#prune_count =  prune_count + 1
            			return best_score
                		break
                	alpha = max(alpha, best_score)
                	#print "Alpha", alpha
        	return best_score
    	else:
        	if depth > max_depth:
        		#print "depth", depth
			return evaluation_function(board_state, isMax, points)
        	best_score = float('inf')
        	main_dict, main_list = find_consecutive_fruit_counts(board_state)
        	#print "depth", depth
        	#print "Min main dict", main_dict
		for ml in main_list:
			key = ml
			cloned_board_state = copy.deepcopy(board_state)
			val = main_dict[key]
			#print "Min val", val
			cloned_board_state = gravity_effect(cloned_board_state, val)
			#print "Min Board State after gravity", cloned_board_state
        	    	best_score = min(best_score, minimax(cloned_board_state, depth+1, True, points-(len(val) * len(val)), alpha, beta, max_depth))
        	    	#print "Min Best score", best_score
        	    	#print "Beta", beta
            		if best_score <= alpha:
            			#print "Best_score", best_score
            			#print "********Pruned********"
            			#global prune_count
            			#prune_count =  prune_count + 1
            			return best_score
                		break
                	beta = min(beta, best_score)
                	#print "Beta", beta
        	return best_score


def find_consecutive_fruit_counts(board_state):
	main_list = []
	main_dict = {}
	l = 0
	length_of_max_list = 0
	index_to_win = -1
	for i in range(0, len(board_state)):
		for j in range(0, len(board_state[i])):
			current_list = []
			#print i, j
			#print board_state[i][j]
			if (board_state[i][j] != "*") and ([i, j] not in main_list):
				current_list.append([i, j])
				main_list.append([i, j])
				current_fruit = board_state[i][j]
				ind = 0
				k = 0
				while k < len(current_list):
					row = current_list[k][0]
					col = current_list[k][1]
					#print current_list
					#print row, col
					if (row - 1) >= 0:
						if (board_state[row-1][col] != "*") and (board_state[row-1][col] == current_fruit) and ([row-1, col] not in current_list):
							current_list.append([row-1,col])
							main_list.append([row-1,col])
					if (row + 1) < len(board_state):
						if (board_state[row+1][col] != "*") and (board_state[row+1][col] == current_fruit) and ([row+1, col] not in current_list):
							current_list.append([row+1,col])
							main_list.append([row+1,col])
					if (col - 1) >= 0:
						if (board_state[row][col-1] != "*") and (board_state[row][col-1] == current_fruit) and ([row, col-1] not in current_list):
							current_list.append([row,col-1])
							main_list.append([row,col-1])
					if (col + 1) < len(board_state):
						if (board_state[row][col+1] != "*") and (board_state[row][col+1] == current_fruit) and ([row, col+1] not in current_list):
							current_list.append([row,col+1])
							main_list.append([row,col+1])
					k = k + 1
				main_dict[l] = current_list
				#if len(current_list) > length_of_max_list:
				#	length_of_max_list = len(current_list)
				#	index_to_win = l
				current_list = []
				l = l + 1
	#print main_dict
	#return main_dict[index_to_win]
	#a = sorted(main_dict, key=lambda main_dict: len(main_dict[k]))
	#print a
	#a = sorted(main_dict.items(), key=lambda main_dict: len(main_dict[1]), reverse=True)
        	#print key,
	#print len(main_dict[0])
	#sorted(main_dict, key = )
	#a = sorted(main_dict.items(), key=lambda v: len(v[1]), reverse=True)
	main_list = []
	for w in sorted(main_dict.items(), key=lambda v: len(v[1]), reverse=True):
		main_list.append(w[0])
	return main_dict, main_list 

def check_board_empty(board_state_after_gravity):
	for i in range (0, len(board_state_after_gravity)):
		for j in range (0, len(board_state_after_gravity[i])):
			if board_state_after_gravity[i][j] != "*":
				return False
	return True


def dfs(board_state, points, depth, i, max_turn, temp):
	if (check_board_empty(board_state)) == False:
		main_dict = find_consecutive_fruit_counts(board_state)	
		#print "Main_dict", main_dict		
		for key in main_dict:
			#print "key", key
			val = main_dict[key]
			print "val", val
			#print "**Points before**", points
			original_points = points
			if (max_turn == 1):
				points = points + (len(val) * len(val))
				max_turn = -1
			else:
				points = points - (len(val) * len(val))
				max_turn = 1
			#print "**Points after**", points
			global leaf_node_val
			leaf_node_val.append([points, i])
			#print leaf_node_val
			original_board_state =  copy.deepcopy(board_state)
			board_state = gravity_effect(board_state, val)
			#print "Board_state_after_gravity", board_state
			i = i + 1
			#print i
			if i == depth:
				board_state = copy.deepcopy(original_board_state)
				#leaf_node_val.append([points, i])
				points = original_points
				max_turn = max_turn * (-1)
				i = i - 1
			else:	
				if(dfs(board_state, points, depth, i, max_turn, temp) == True):
					return True
				else:
					board_state = copy.deepcopy(original_board_state)
					#leaf_node_val.append([points, i])
					points = original_points
					max_turn = max_turn * (-1)
					i = i - 1
					#print i
	else:
		#print "Leaf node", leaf_node_val
		return False	
	
				
def gravity_effect(board_state, max_position):
	board_state_after_gravity = board_state[:]
	for i in range (0, len(max_position)):
		row = max_position[i][0]
		col = max_position[i][1]
		board_state_after_gravity[row][col] = "*"
	max_position.sort(key=lambda x:(x[1], x[0]))
	#print "#########"
	#print max_position
	num_col = len(board_state)
	for i in range (len(max_position) - 1, -1, -1):
		row = max_position[i][0]
		col = max_position[i][1]
		if num_col > col:
			num_col = col
			current_row = row
			row = row - 1
			while row > -1:
				if board_state_after_gravity[row][col] != "*":
					board_state_after_gravity[current_row][col] = board_state_after_gravity[row][col]
					board_state_after_gravity[row][col] = "*"
					current_row = current_row - 1
				row = row - 1
	#file_write(board_state_after_gravity, max_position)
	return board_state_after_gravity 

file_input = open('input.txt', 'r')
file_output = open('output.txt', 'w+')
size_of_board = int(file_input.readline().strip())
number_of_fruits = int(file_input.readline().strip())
time_remaining_given = float(file_input.readline().strip())
board_state = []
for line in file_input.readlines():
	line = line.replace("\n", "")
	line = line.replace("\t", "")
	line = line.replace("\r", "")
	line = line.replace(" ", "")
	each_row = []
	for i in range (0, len(line)):
		if line[i] != "*":
			each_row.append(int(line[i]))
		else:
			each_row.append(line[i])
	board_state.append(each_row)
#print board_state

#max_position = find_consecutive_fruit_counts(board_state)
max_turn = 1
temp = []
alpha = float("-inf")
beta = float("inf")
max_depth = 1
original_board_state =  copy.deepcopy(board_state)
best_key = find_best_move(board_state, max_depth, time_remaining_given)
board_state_after_gravity = gravity_effect(original_board_state, best_key)
file_write(board_state_after_gravity, best_key)
print time.time()-start

#print "After returning max_parent", best_key
#print function_count
#print prune_count
#print a
#a = dfs(board_state, 0, 4, 0, max_turn, temp)


#main_dict = find_consecutive_fruit_counts(board_state)
#board_state_after_gravity = gravity_effect(board_state, max_position)

#print max_position

#print "------------------------"
#for i in range (0, len(board_state_after_gravity)):
#	print board_state_after_gravity[i]
